
# Code Refactoring
بازآرایی کد 

 ### دستور کار:

https://github.com/ssc-public/Software-Engineering-Lab/blob/main/agendas/refactoring.md

### مراحل انجام آزمایش:

- پروژه ی جاوای داده شده را دانلود میکنیم.

- الگوی facade:

  در این بازآرایی، الگوی Facade برای ساده‌تر کردن واسط با سایر اجزای پروژه به کار گرفته می‌شود. با استفاده از یک کلاس واسط (Facade)، عملکردهای مرتبط را در یک نقطه تجمیع می‌کنیم و از طریق این واسط با سیستم تعامل می‌کنیم.

  - ScannerNew:

     کلاس جدید به نام ScannerNew ایجاد میکنیم. این کلاس مسئول ایجاد نمونه‌ی Scanner و واسطی ساده برای استفاده از Scanner در کلاس Parser است. که به صورت مستقیم با ارتباط برقرار نکنند.

  - CodeGeneratorNew:

    کلاس جدید به نام CodeGeneratorNew ایجاد میکنیم. این کلاس مسئول ایجاد نمونه‌ی CodeGenerator و واسطی ساده برای استفاده از CodeGenerator در کلاس Parser است. که به صورت مستقیم با ارتباط برقرار نکنند.

  هردو کلاس CodeGenerator و scanner را از حالت پابلیک در میاریم تا امنیت بیشتر شود.

- الگوی Polymorphism:

    با استفاده از Polymorphism، می‌توانیم شرط‌ها را به صورت یک ساختار سلسله‌مراتبی از کلاس‌ها و روش‌ها جایگزین کنیم. این باعث می‌شود کد خوانا‌تر، قابل‌تعمیم‌پذیرتر و تغییرپذیرتر شود.
   
    به جای switch case در کلاس action آن کلاس را ابسترکت کرده 
    , حالت های swich را بچه های آن قرار میدهیم.
    یک پوشه actions ایجاد کرده و کلاس های action, act, accept, reduce و shift را در آن قرار میدهیم.

- الگوی Separate Query From Modifie:

  در این بازآرایی، جدا کردن عملیاتی که مقدار برمی‌گردانند (Query) از عملیاتی که مقدار را تغییر می‌دهند (Modifier) به منظور جدا سازی نگرانی‌های مربوط به تغییر و ایجاد رفتارهای قابل تشخیص و قابل استفاده می‌شود.

  در اینجا تابع getNextParameter که مقدار را همان جا گرفته و تغییر میدهد را تغییر میدهیم و بک تابع جدید اضافه میکنیم که آن مقدار را تغییر داده و به getNextParameter میدهد.

- Self Encapsulated Field  , الگوهای دیگر:

  - Self Encapsulated Field:

    در این بازآرایی، ویژگی‌های کلاس را به صورت private تعریف کرده و به عنوان private فراخوانی می‌کنیم. به جای دسترسی مستقیم به خصیصه‌ها، از متدهای Getter و Setter استفاده می‌کنیم تا اطمینان حاصل کنیم که تمام عملیات بر روی خصیصه‌ها از طریق متدها انجام می‌شود.
      برای symboltable, getter و setter اعمال میکنیم.

  - Remove Assignments to Parameters:

    قاعدة بازآرایی برای حذف عملیات تخصیص مقدار به پارامترها در تابع‌ها استفاده می‌شود. این بازآرایی به شما کمک می‌کند تا کدهایی که مقداری به پارامترها اختصاص می‌دهند را بهبود بخشید و قابل خواندن‌تر و قابل تغییر‌پذیرتر کنید.
    در ParseTable به جای تغییر ورودی تابع که jsonTbale است یک متغییر محلی تعریف میکنیم و آن را تغییر میدهیم و استفاده میکنیم.

  - Extract Method:

      قاعده بازآرایی برای جدا کردن بخشی از کد تکراری و ایجاد یک متد جداگانه به منظور اجرای آن بخش از کد مورد استفاده می‌شود. این بازآرایی به شما کمک می‌کند کد تکراری را به متد جداگانه‌ای منتقل کنید و در صورت نیاز در جایگاه‌های مختلف برنامه از آن متد استفاده کنید.
      در کلاس codegenarator یک بخش 3 بار تکرار شده بود که به جای تکرار آن تابعی ایجاد کردیم و تابع را صدا زدیم.


## پرسش‌ها

 - هر یک از مفاهیم زیر را در حد یک خط توضیح دهید.


    - کد تمیز:
    
      کدی است که به راحتی قابل خواندن، درک و تغییر است. از اصول نگارشی مناسب استفاده می‌کند و سازماندهی منطقی دارد.
      
    
     - بدهی فنی:
      
        مجموعه از مشکلات و نقص‌های فنی در ساختار و طراحی کد است که موجب کاهش کیفیت و قابلیت تغییر و توسعه آن می‌شود.
    
    
     - بوی بد:
     
        نشانگر وجود مشکلات و نقص‌هایی در کد است که باعث سختی‌ها و ابهامات در فهم و تغییر کد می‌شود.


  - طبق دسته‌بندی وب‌سایت refactoring.guru، بوهای بد کد به پنج دسته تقسیم 
    می‌شوند. در مورد هر کدام از این پنج دسته توضیح مختصری دهید.

    در صفحه مورد نظر، پنج مورد از بوی‌های بد کد (Code Smells) تعریف شده‌اند. این موارد عبارتند از:

    - Bloaters (پف‌ها):
    
      کد، متدها و کلاس‌هایی که به اندازه زیادی بزرگ شده‌اند و باعث مشکلات در کار با آنها می‌شوند. این بوی‌ها به طور معمول به مرور زمان در طول تکامل برنامه تجمع می‌یابند و به ویژه زمانی که هیچ تلاشی برای از بین بردن آنها صورت نگیرد.

    - Object-Orientation Abusers (سوءاستفاده از شیءگرایی): 
      
      این بوی‌ها نشان دهنده استفاده ناقص یا نادرست از اصول برنامه‌نویسی شیءگرا هستند.

    - Change Preventers (موانع تغییر): 
      
      این بوی‌ها به این معنی هستند که اگر نیاز به تغییری در یک قسمت از کد داشته باشید، باید تغییرات زیادی در قسمت‌های دیگر نیز انجام دهید. این موضوع باعث پیچیدگی و هزینه بیشتر در توسعه برنامه می‌شود.

    -  Dispensables (قابل از بین بردن): 
      
        این بوی‌ها به چیزهای بیهوده و غیرضروری اشاره دارند که عدم وجود آنها باعث تمیزتر، کارآمدتر و قابل فهم‌تر شدن کد می‌شود.

    - Couplers (اتصال‌ها): 
        
      تمامی بوی‌های این گروه موجب اتصال زیاد بین کلاس‌ها می‌شوند و نشان می‌دهند که چه اتفاقی رخ می‌دهد اگر اتصال به وفور با استفاده از وفوریت جایگزین شود.


  - یکی از انواع بوهای بد، Lazy Class است.

    - این بوی بد در کدام یک از دسته‌بندی‌های پنج‌گانه قرار می‌گیرد؟

         بوی بد Lazy Class در رده بوهای بد Dispensable قرار می‌گیرد. Lazy Class به کلاسی اطلاق می‌شود که کار کمی انجام می‌دهد و می‌توان آن را با کلاس دیگری جایگزین کرد. این کلاس‌ها به دلیل عدم فعالیت معنادار و عملکرد کم، از منظر تمیزی کد اضافه هستند و می‌توانند از بین برده شوند تا کد تمیزتر، ساده‌تر و قابل فهم‌تری را به ما ارائه دهند. 

    - برای برطرف‌کردن این بو، استفاده از کدام بازآرایی‌ها پیشنهاد می‌شود؟
      
      - حذف میانجی (Remove Middle Man):

        در این روش، کلاس Lazy Class که کار کمی انجام می‌دهد و به عنوان یک واسطه میان دیگر کلاس‌ها عمل می‌کند، حذف می‌شود. به جای استفاده از Lazy Class، مستقیماً با کلاس‌های دیگر ارتباط برقرار می‌کنیم. این کار می‌تواند منجر به ساده‌سازی کد و کاهش پیچیدگی شود، زیرا از واسطه‌های اضافی و غیرضروری خلاص می‌شویم.

      - جایگزینی با استفاده از کلاس دیگر (Inline Class):

        در این روش، کلاس Lazy Class با یک کلاس دیگر جایگزین می‌شود که تنها شامل عملکردها و ویژگی‌های مورد نیاز است. عملکردها و ویژگی‌های Lazy Class به صورت مستقیم در کلاس جدید قرار می‌گیرند و کلاس Lazy Class حذف می‌شود. این عمل باعث کاهش اضافه‌کاری و پیچیدگی نامربوط در کد می‌شود و کد را تمیزتر و قابل فهم‌تر می‌کند.

      
    - در چه مواقعی باید این بو را نادیده گرفت؟

        این بوی بد به دلیل اهداف توسعه آینده ایجاد میشود، در این مورد،  تعادلی بین وضوح و سادگی باید ایجاد کرد.
    
 










