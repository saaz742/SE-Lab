# تمرین اول

*امیر معینی، سارا آذرنوش*

# پرسش‌ها

۱. 
این پوشه عملا 
working directory
نرم‌افزار 
git
است. 
این پوشه شامل تمام اطلاعات مربوط به 
version control
پروژه مانند فایل‌های 
object 
(که شامل کامیت‌ها، فایل‌های موجود در پروژه و همچنین ساختار پوشه‌هاست)،
فایل‌های 
ref
(برای نگهداری برنچ‌ها، تگ‌ها و ...)
، فایل‌ کانفیگ و ... است.
با زدن دستور 
`git init`
فولدری که در آن هستیم آماده‌ی version control می‌شود 
و متعاقبا این پوشه نیز ایجاد می‌شود.

۲.
یعنی اینکه هر 
commit
یا 
pull request
مربوط به دقیقا یک تغییر معنادار که می‌توان آن را در یک جمله توصیف کرد باشد نه اینکه چندین کار را با هم انجام دهد یا اینکه اصلا بدون 
commitهای
بعدش بی‌معنی باشد و هیچ تغییر معناداری در پروژه ایجاد نکرده باشد.

۳.
دستور
`git fetch`
صرفا از اطلاعات لوکال راجع به ریموت را آپدیت می‌کند. این اطلاعات شامل کامیت‌ها و وضعیت برنچ‌هاست. ولی `git pull` علاوه بر
همین‌کار، عملیات ادغام شاخه‌ی لوکال کنونی با شاخه‌ی متناظرش در ریموت را نیز انجام می‌دهد. این ادغام می‌تواند توسط rebase
یا 
merge باشد.
در merge تغییرات شاخه‌ی دیگری در طی یک کامیت در شاخه‌ی کنونی، به این شاخه اضافه می‌شوند. اما در rebase
تک تک کامیت‌های برنچ دیگری، بعد از آخرین نقطه مشترک آن برنچ با برنچ کنونی، در برنچ کنونی قرار می‌گیرند(و ممکن است به ازای هر کدام از آنها مجبور به حل کردن conflict شویم!)، یعنی عملا پایه‌ی آن برنچ، به آخرین کامیت برنچ کنونی تغییر میکند.

۴. در این بین، revert
متفاوت‌ترین است و عملا کامیتی ایجاد می‌کند که هدف آن بازگردانی تغییراتی است که یک کامیت خاص به وجود آورده است. restore با کانفیگ‌های مختلف می‌تواند کد یک کامیت را بردارد و در stage بگذارد یا اینکه حتی آن را در working directory بگذارد. شبیه این کار را 
`git reset --mixed` و 
`git reset --hard`
نیز انجام می‌دهند. ولی نکته‌ای که وجود دارد این است که دستور `reset`
 می‌تواند ‍‍ref یک برنچ را به کامیت‌های قبل‌تر ببرد، این کار را restore نمی‌تواند انجام دهد.

۵. عملا یک کامیت نا‌تمام است که در 
`.git/index`
 نگهداری می‌شود و می‌توانیم به مرور آن را کامل کنیم و در نهایت به عنوان یک کامیت کامل آن را ثبت کنیم. دستور stash عملا یک object کامیت می‌سازد و آن را داخل یک استک می‌گذارد. هر موقع که خواستیم می‌توانیم این کامیت‌ها را بیرون بیاوریم و روی working directory اعمال کنیم. دقت کنید که این کامیت‌ها در درخت اصلی کامیت‌ها جای ندارند.

 ۶. گیت برخلاف برخی از نرم‌افزار‌های version control دیگر تفاوت دو استیت یک فایل را نگه نمی‌دارد، بلکه یک اسنپ‌شات که شامل کل استیت آن فایل است نگه می‌دارد و آن را در عملیات‌هایش استفاده می‌کند.

 # گزارش مختصر
 ابتدا با نصب ابزار `gh`
 سعی کردم تنها با استفاده از کمندلاین، مدیریت پروژه را انجام دهم و به وسیله آن مخزن را بسازم. ابتدا مخزن را در حالت خصوصی ساختم و همچنین از `.gitignore`
 پیشنهادی استفاده کردم، البته چون قرار بود بعد از dataspell برای زدن پروژه استفاده کنم، پوشه `.idea` را نیز به آن افزودم.

 با استفاده از [این لینک](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow) 
 ساختار یک پروژه که دارای برنچ‌های معنادار است را ایجاد کردم. این ساختار شامل دو برنچ اصلی `main` و `develop` است و تعدادی برنچ
 `hotfix`, `feature` و `release`
  نیز دارد. 

  سپس از بخش تنظیمات مخزن، شاخه اصلی در این ساختار که `main`
   است را در حالت محافظت شده قرار دادم. سپس به سراغ برنامه ریزی releaseها رفتم. دو ریلیز پاسخ به پرسش‌ها و پروژه را در نظر گرفتم و سپس با ساختن فایل README و افزودن آن به شاخه develop شروع به زدن فیچر سوالات در شاخه مختص آن کردم. در نهایت این شاخه را با develop مرج کرده و به همراه فیچر قبلی، شاخه ریلیز را ساخته و پول‌ریکوئست آن را ثبت و ادغام کردم. در مرحله بعد فیچر‌های مختلف پروژه را ایجاد کردم و بعد از مرج کردن آنها با develop و رفع کردن conflictهای پیش‌آمده، یک ریلیز ساختم و در شاخه ریلیز `Pipfile.lock` را اضافه کردم و در نهایت پول ریکوئست دادم و آن را با main مرج کردم. این گزارش را به عنوان یک hotfix در نظر خواهم گرفت چون عملا باید در ریلیز پروژه میبود ولی به اشتباه این اتفاق نیفتاد.